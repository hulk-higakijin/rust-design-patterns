# オブジェクトベースAPI

## 説明

他言語に公開されるRust APIを設計する際、通常のRust API設計とは反対の重要な設計原則があります：

1. すべてのカプセル化された型は、Rustが*所有*し、ユーザーが*管理*し、*不透明*であるべきです。
2. すべてのトランザクショナルデータ型は、ユーザーが*所有*し、*透過的*であるべきです。
3. すべてのライブラリの振る舞いは、カプセル化された型に作用する関数であるべきです。
4. すべてのライブラリの振る舞いは、構造ではなく*由来/ライフタイム*に基づく型にカプセル化されるべきです。

## 動機

Rustには他言語へのFFIサポートが組み込まれています。これは、クレート作成者が異なるABIを通じてC互換APIを提供する方法を提供することで実現されています（この実践においては重要ではありませんが）。

よく設計されたRust FFIは、C API設計原則に従いつつ、可能な限りRust側の設計を妥協しないようにします。外部APIには3つの目標があります：

1. ターゲット言語で使いやすくする。
2. API がRust側の内部的な unsafe を可能な限り強制しないようにする。
3. メモリ安全性違反とRustの`未定義動作`の可能性を可能な限り小さく保つ。

Rustコードは、ある時点を超えて外部言語のメモリ安全性を信頼する必要があります。しかし、Rust側のすべての`unsafe`コードは、バグの機会であり、`未定義動作`を悪化させる機会でもあります。

例えば、ポインタの由来が間違っている場合、無効なメモリアクセスによるセグメンテーション違反になる可能性があります。しかし、unsafeコードによって操作されると、完全なヒープ破壊になる可能性があります。

オブジェクトベースAPI設計により、良好なメモリ安全性特性を持つshimを記述でき、安全なものと`unsafe`なものの明確な境界を作ることができます。

## コード例

POSIX標準は、[DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h)として知られるファイルベースのデータベースにアクセスするためのAPIを定義しています。これは「オブジェクトベース」APIの優れた例です。

以下はCでの定義で、FFIに関わる方々には読みやすいはずです。下記の解説は、細かい点を見逃した方々の理解を助けるでしょう。

```C
struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
```

このAPIは2つの型を定義しています：`DBM`と`datum`。

`DBM`型は、上記で「カプセル化された」型と呼ばれました。これは内部状態を含むように設計されており、ライブラリの振る舞いのエントリーポイントとして機能します。

これはユーザーにとって完全に不透明であり、ユーザーはそのサイズやレイアウトを知らないため、`DBM`を自分で作成することはできません。代わりに、`dbm_open`を呼び出す必要があり、それは*ポインタのみ*を提供します。

これは、すべての`DBM`がRustの意味でライブラリによって「所有」されていることを意味します。未知のサイズの内部状態は、ユーザーではなくライブラリによって制御されるメモリに保持されます。ユーザーは`open`と`close`でそのライフサイクルを管理し、他の関数で操作を実行することしかできません。

`datum`型は、上記で「トランザクショナル」型と呼ばれました。これはライブラリとユーザー間の情報交換を容易にするように設計されています。

データベースは「非構造化データ」を格納するように設計されており、事前定義された長さや意味はありません。その結果、`datum`はRustスライスに相当するCの等価物です：バイトの塊と、その数のカウント。主な違いは型情報がないことで、これが`void`が示すものです。

このヘッダーはライブラリの視点から書かれていることに注意してください。ユーザーはおそらく既知のサイズを持つ何らかの型を使用しているでしょう。しかし、ライブラリは気にせず、Cのキャストルールにより、ポインタの背後にある任意の型は`void`にキャストできます。

前述のように、この型はユーザーにとって*透過的*です。しかし、この型はユーザーが*所有*します。これには、内部のポインタのため、微妙な影響があります。問題は、そのポインタが指すメモリを誰が所有するかです。

メモリ安全性のための最良の答えは「ユーザー」です。しかし、値を取得する場合など、ユーザーは正しく割り当てる方法を知りません（値の長さがわからないため）。この場合、ライブラリコードはユーザーがアクセスできるヒープ（Cライブラリの`malloc`や`free`など）を使用し、Rustの意味で*所有権を移転*することが期待されます。

これはすべて推測に見えるかもしれませんが、これがCにおけるポインタの意味です。Rustと同じことを意味します：「ユーザー定義のライフタイム」。ライブラリのユーザーは、正しく使用するためにドキュメントを読んで理解する必要があります。とはいえ、ユーザーが間違えた場合の結果が少ないか大きいかという決定があります。それらを最小化することがこのベストプラクティスの目的であり、鍵は*透過的なすべてのものの所有権を移転すること*です。

## 利点

これにより、ユーザーが守らなければならないメモリ安全性保証の数を比較的少数に最小化できます：

1. `dbm_open`によって返されないポインタで関数を呼び出さない（無効なアクセスまたは破損）。
2. closeの後にポインタで関数を呼び出さない（解放後の使用）。
3. 任意の`datum`の`dptr`は`NULL`であるか、宣伝された長さの有効なメモリスライスを指している必要があります。

さらに、多くのポインタ由来の問題を回避します。その理由を理解するために、代替案を詳しく検討しましょう：キーの反復。

Rustはイテレータでよく知られています。実装する際、プログラマーは所有者に制限されたライフタイムを持つ別の型を作成し、`Iterator`トレイトを実装します。

以下は`DBM`に対するRustでの反復の実装です：

```rust,ignore
struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys<'it>(&'it self) -> DbmKeysIter<'it> { ... }
    /* ... */
}

struct DbmKeysIter<'it> {
    owner: &'it Dbm,
}

impl<'it> Iterator for DbmKeysIter<'it> { ... }
```

これはクリーンで、慣用的で、安全です。Rustの保証のおかげです。しかし、単純なAPI変換がどのように見えるか考えてみましょう：

```rust,ignore
#[no_mangle]
pub extern "C" fn dbm_iter_new(owner: *const Dbm) -> *mut DbmKeysIter {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern "C" fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -> libc::c_int {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern "C" fn dbm_iter_del(*mut DbmKeysIter) {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
```

このAPIは重要な情報を失います：イテレータのライフタイムは、それを所有する`Dbm`オブジェクトのライフタイムを超えてはなりません。ライブラリのユーザーは、イテレータが反復するデータより長生きするような使い方をする可能性があり、初期化されていないメモリの読み取りを引き起こします。

Cで書かれたこの例には、後で説明するバグが含まれています：

```C
int count_key_sizes(DBM *db) {
    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &key)) >= 0) { // an error is indicated by -1
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // end of the iterator
            dbm_close(owner);
        }
    }
    if l >= 0 {
        return -1;
    } else {
        return len;
    }
}
```

このバグは古典的です。イテレータが反復終了マーカーを返したときに何が起こるかを示します：

1. ループ条件が`l`をゼロに設定し、`0 >= 0`であるためループに入ります。
2. 長さが増加します。この場合はゼロだけ。
3. if文が真になるため、データベースが閉じられます。ここにbreak文があるべきです。
4. ループ条件が再度実行され、閉じられたオブジェクトに対して`next`呼び出しが発生します。

このバグの最悪な部分は？Rust実装が注意深い場合、このコードはほとんどの場合動作します！`Dbm`オブジェクトのメモリがすぐに再利用されなければ、内部チェックがほぼ確実に失敗し、イテレータはエラーを示す`-1`を返します。しかし時折、セグメンテーション違反を引き起こし、さらに悪いことに、意味不明なメモリ破壊を引き起こします！

これのどれもRustでは回避できません。Rustの観点からは、それらのオブジェクトをヒープに置き、それらへのポインタを返し、それらのライフタイムの制御を放棄しました。Cコードは単に「きちんと振る舞う」必要があります。

プログラマーはAPIドキュメントを読んで理解する必要があります。Cではそれが当然と考える人もいますが、良いAPI設計はこのリスクを軽減できます。`DBM`のPOSIX APIは、イテレータの所有権を親と*統合*することでこれを実現しました：

```C
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
```

したがって、すべてのライフタイムが結び付けられ、そのような安全性違反が防止されました。

## 欠点

しかし、この設計選択には多くの欠点もあり、それも考慮すべきです。

まず、API自体が表現力に欠けるようになります。POSIX DBMでは、オブジェクトごとに1つのイテレータしかなく、すべての呼び出しがその状態を変更します。これは安全ではありますが、ほぼすべての言語のイテレータよりもはるかに制限的です。おそらく他の関連オブジェクトでは、ライフタイムがあまり階層的でない場合、この制限は安全性よりもコストが高くなります。

次に、APIの部分の関係によっては、重要な設計努力が必要になる場合があります。より簡単な設計ポイントの多くには、他のパターンが関連付けられています：

- [ラッパー型の統合](./wrappers.md)は、複数のRust型を不透明な「オブジェクト」にグループ化します

- [FFIエラー処理](../../idioms/ffi/errors.md)は、整数コードとセンチネル戻り値（`NULL`ポインタなど）を使用したエラー処理を説明します

- [外部文字列の受け入れ](../../idioms/ffi/accepting-strings.md)は、最小限のunsafeコードで文字列を受け入れることができ、[FFIへの文字列の受け渡し](../../idioms/ffi/passing-strings.md)よりも正しく実装しやすいです

しかし、すべてのAPIがこの方法で実行できるわけではありません。対象者が誰であるかは、プログラマーの最善の判断に委ねられています。
